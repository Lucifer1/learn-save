1. 尽量少修改公共的东西，做判断的话在自己写需求的地方加判断
2. 如果能从数据层面解决问题就不要增加不必要的代码
3. 虚环境：可以在本地或者测试环境上，将请求代理到swagger上边，这样的话就可以使用swagger的mock数据了，swagger里边的调试那里可以测试请求，那边的数据可以拿过来mock用
4. 虚环境的添加：
    1.  在页面对应的template里边添加一个js

            ```
            <% if (process.env.VUE_APP_CONFIG === 'test' || process.env.VUE_APP_CONFIG === 'dev') {
            %>
            <script src="https://xyks.yuanfudao.biz/h5/venv-tools/venv-tools-0.0.3.js"></script>
            <% } %>
            ```
        需要注意的是，if的判断条件，不同项目里边关于test和dev的定义可能是不一样的，这次碰到的是，vue-cli3的项目里边是上边这种，vue-cli2里边是process.env.NODE_ENV === 'production'，process.env.NODE_ENV === 'development'

5. 刘海屏与安全区
6. VIP专区页，试卷还原模块，点金更多触发两次页面，原因是因为在模块整体加了一个跳转来实现点击模块任意位置都可以跳转，然后在更多那边也有一个点击事件是跳转，所以当点击更多时，会触发两次
    1.  解决方法：阻止更多那边的click事件的冒泡，@click.stop
7. 考虑各种页面跳入同一个页面，这个页面back按钮的，function情况，是closeWebview还是go(-1)
8. border-radius 与 overflow的问题
    1.  父元素设置了barder-radius，子元素有可能会把父元素的圆角盖住
    2.  可以通过给父元素设置overflow:hidden解决
9. 我们隐藏了webview自带的bar，手机的返回按钮调取的是我们传给客户端的trigger的方法，可以通过WebView来进行设置

        ```
        WebView.setLeftButton({
            trigger: () => {
                .....leftButton的function.....
            }
        })
        ```

10. 写代码的时候要考虑性能优化，减少发送请求，在购买混入那边，将请求客户端的桥方法放在了混入的mounted里边，混入在selector里边与VipPurchase里用了两次，所以mounted了两次，那个请求也就发了两次
11. **另外一个性能问题：让数据请求的时机更早一点，例子**
     1.   和问题107一起看，我的写法是在购买成功后，调取store里边的方法，这里需要await客户端的桥方法，如果客户端的方法很慢的话，会影响用户体验
     2.   文静的方法是；store里边的function，返回一个promise，然后进入VipPurchase页面的monted时，就调用这个方法，它返回一个promise，然后在购买成功时，await这个promise，这样的话请求时机就从购买成功才调用客户端的桥方法变成了，进入这个页面就调用客户端的桥方法。
12. SKU是标准化产品单元，区分品种；SKU是库存量单位，区分单品；商品特指与商家有关的商品，可对应多个SKU。首先，搞清楚商品与单品的区别。例如，iphone是一个单品，但是在淘宝上当很多商家同时出售这个产品的时候，iphone就是一个商品了。
13. 点击bottombutton时，有可能图片没有渲染完成，设置了一个disable变量，如果图片没有渲染完成，就不让点击这个button
14. new Date在ios上返回 invalid Date，在ios里不支持 '-' 连接的日期，所以为了兼容ios，将日期转换为 '/' 连接的。
     1.   var d = new Date("2017-08-11 12:00:00".replace(/-/g, "/"));
15.  做的优化，以及用户体验的考虑，组件的抽离与设计
16.  更换短链其实就是使用302和相应头的location进行一个重定向
17.  弹窗显示禁止滚动，其实就是Watch控制弹窗显示的变量，当newVal为true时，给body添加overflow = hidden,position = fixed，当newVal为false时，overflow = auto，position = relative
18.  发请求的地方最好都用try catch包一下
19.  埋点的抽离

    ```
    @Watch('isVisible')
    isVisibleChange (val: boolean) {
        let finishType = this.success ? 1 : 2
        let frogMethod = val ? this.$addEventFrog : this.$addClickFrog
        if(this.isApp) {
            let appFrogUrl = val ? 'promotion/finishPop' : 'promotion/finishPop/close'
            try {
            frogMethod(appFrogUrl, {
                keyfrom: this.keyfrom,
                activityTag: 'promotion2021',
                VIPType: this.VIPType,
                userPeriod: this.doubleElevenInfo.status,
                finishType
            })
            } catch (err) {
            console.log('>>>', 'err', err)
            }
        } else {
            let appFrogUrl = val ? 'finishPop' : 'finishPop/close'
            try {
            frogMethod(appFrogUrl, {
                shareuserId: this.shareUserId,
                userId: this.ytkUserId,
                finishType
            })
            } catch (err) {
            console.log('>>>', 'err', err)
            }
        }
    }
    ```
    1. 分位端内和端外的支付弹窗，因为成功和失败只有url和finishType不同，所以提取出来，根据状态赋予不同的值
    2. 成功和失败调用的方法不同，一个是event一个是click
       1. 最开始使用的方法

            ```
            let frogMethod = val ? '$addEventFrog' : '$addClickFrog'
            this[frogMethod]
            报错
            ```
            说this上找不到frogMethod这个属性，直接使用this['$addClickFrog']是可以的，没法解决

        1. 后来使用的是上述代码中的方法
20.
#### HTML

1. HTML语义化
2. viewport
3. DOM基本操作、nodelist与collection
4. localStorage与sessionStorage
5. canvas 1px
6. 元信息类标签

#### CSS

1. 盒子模型
2. 选择器及优先级
3. 继承
4. 新增伪类
5. 水平垂直居中
6. display有哪些值及作用
7. 颜色转换
8. 媒体查询
9. 画三角
10. margin，margin：auto的含义
11. visibility与display区别
12. visibility属性有个collapse属性值？在不同浏览器下以后什么区别？
13. position跟display、overflow、float这些特性相互叠加后会怎么样？
    1.  display属性规定元素应该生成的框的类型；position属性规定元素的定位类型；float属性是一种布局方式，定义元素在哪个方向浮动。类似于优先级机制：position：absolute/fixed优先级最高，有他们在时，float不起作用，display值需要调整。float 或者absolute定位的元素，只能是块元素或表格。
14. BFC
15. 清除浮动
16. margin塌陷，margin合并
17. 设置元素浮动后，该元素的display值是多少？ 自动变成display：block
18. less
19. css优化
20. margin与padding
21. 如果需要手动写动画，你认为最小时间间隔是多久，为什么？
    1.  多数显示器默认频率是60Hz，即1秒刷新60次，所以理论上最小间隔为1/60＊1000ms ＝ 16.7ms。
22. css位置
23. flex
24. GPU加速渲染
25. postcss
26. 安全区域
27. iPhoneX安全区域、苹果刘海屏
28. postcss
29. visibility:collapse
30. 小于 12px 的文本
31. min-width与max-width
32. RGBA、HSLA(色相(hue)-饱和度(saturation)-亮度(lightness))，看掘金
33. z-index生效条件：position 属性值不是 static
34. link 和 @import

#### JavaScript

1. 基本数据类型
2. map、weakmap、set、weakset
3. 原型链
4. this
5. 深拷贝与浅拷贝
6. 事件冒泡与捕获及应用、事件委托
7. 继承、prototype、__proto__、constructor的关系
8. 事件循环
9. 常用的promise方法
10. 设计模式
11. 柯里化与函数式编程
12. 首屏加载
13. Array的方法，ES6的方法，以及原有的方法，哪些改变原数组哪些不改变
14. babel与polyfill
15. 更换短链原理
16. webview
17. 跨域问题
18. 双等号与三等号
19. typeof instanceOf Object.prototype.toString类型判断
20. null与undefined
21. symbol
22. generator
23. 闭包
24. && ||
25. defer与async
26. 重排与重绘，documentFragment
    1.  DocumentFragment 节点不属于文档树，继承的 parentNode 属性总是 null。 当请求把一个 DocumentFragment 节点插入文档树时，插入的不是 DocumentFragment 自身，而是它的所有子孙节点。这使得 DocumentFragment 成了有用的占位符，暂时存放那些一次插入文档的节点。它还有利于实现文档的剪切、复制和粘贴操作，尤其是与 Range 接口一起使用时更是如此。 可以用 Document.createDocumentFragment() 方法创建新的空 DocumentFragment 节点。DocumentFragment 节点不属于文档树，继承的 parentNode 属性总是 null。 **DocumentFragment 节点不属于DOM树，因此它的变化不会引起DOM树的变化；**
    2.  DOM树的操作会引起回流，那我们可以将DocumentFragment作为一个暂时的DOM节点存储器，当我们在DocumentFragment 修改完成时，我们就可以将存储DOM节点的DocumentFragment一次性加入DOM树，从而减少回流次数，达到性能优化的目的。
27. DOM，[交换两个元素位置](https://www.jianshu.com/p/8b6ead8beb3a)
28. 4中for循环
29. map、reduce
30. console.log(Boolean(-1)); === true
31. 跨站与跨域
32. 解构
33.


#### JavaScript 手写

1. new、call、apply、bind
2. promise、promise.all
3. async await
4. 防抖与节流
5. vue双向绑定
6. 事件委托
7. 深拷贝


#### 算法

1. 双指针
2. 滑动窗口
3. 回溯法
4. 动态规划
5. 贪心
6. 堆栈
7. 树
8. 排序，稳定性，最好和最差的时间复杂度

#### Webpack

1. loader与plugin
2. chunk与bundle
3. devServer
4. resolve
5. 符号
6. npm install原理

#### Vue

1. 双向绑定源码
2. nexttick源码
3. vue与react的区别
4. mvc mvp mvvm
5. v-if与v-show
6. computed、watch与methods
7. 虚拟DOM与diff
8. vue3
9. proxy与defineProperty的区别
10. keep-alive与activated
11. 路由懒加载
12. vue + ts中混入的使用
13. .sync
14. history与hash
15. 为什么vue必须要有根节点
    * 因为在diff里边是单节点操作，而不是数组操作，所以必须有一个根节点
16. $nextTick


#### Typescript

1. 看一遍

#### Git

#### 性能优化

1. 性能优化指标
2. 减少请求次数
2. 加快请求速度
3. 加速页面的解析与处理
4. 自己的理解
    * 合理的使用防抖和节流函数，来减少对服务的查询
    * 对于多图的页面，使用图片的懒加载
    * 减少页面发生重排

#### 网络

1. http基本结构
2. 状态码
3. 浏览器从输入url到渲染发生了什么
4. cookie包括samesite属性、session、token
5. https
6. XSS、CSRF
7. DNS重绑定攻击，为什么host可以解决
    1.  因为这个重绑定攻击是诱导用户去访问恶意网站，然后更改恶意网站的ip来实现的，那么被攻击的服务器收到的host的值就是恶意网站的值，如果我们在服务器设置白名单，那么恶意网站一定不在白名单里边，所以可以防止重绑定攻击
8. 三次握手、四次挥手及各个阶段的字段
9. 强缓存与协商缓存
10. http 2.0
11. tcp与udp
12. get与post区别
13. DNS查询过程
14. 七层与四层网络模型
15. localStorage与sessionStorage

#### 浏览器

1. 浏览器的组成
2. 浏览器内核一般是指浏览器的渲染进程
3. 浏览器加载流程
4. 如何减少和避免重排

#### 其他

1. 进程与线程的区别
2. 进程间通讯的方式
3. Git
4. [webview](https://zhuanlan.zhihu.com/p/142800148)相当于一个浏览器，在手机上用webview和在电脑上打开chrome类似
5. 开发思路

#### 亮点与难点

1. 组件的封装与复用
2. 考虑问题的全面性
3. 所学知识的应用
4. 沟通与联调
5. 上方购买按钮消失显示下方的bottombar


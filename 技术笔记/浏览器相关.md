1. 浏览器的组成
    * 浏览器主进程：主要进行网页的创建与销毁相关工作
    * GPU进程：css渲染GPU加速
    * 渲染进程
        - js线程
        - GUI渲染线程
        - 事件触发线程
        - 定时器触发线程
        - 异步http请求线程
        - 注意：js线程与GUI渲染线程互斥，这就是为什么js会阻塞DOM的根本原因
2. 浏览器内核一般是指浏览器的渲染进程
3. 浏览器加载流程
    * 构建DOM树：读取html文档 -> 将字节流解析成字符 -> 根据字符确定标签 -> 根据标签创建节点 -> 根据节点构建DOM树
    * 构建CSSOM树：读取css文档 -> 将字节流解析成字符 -> 根据字符确定标签 -> 根据标签创建节点 -> 根据节点构建CSSOM树
    * 加载JS：浏览器每遇见一个script标签，就会阻塞DOM树的构建，
    * 构建渲染树：渲染树（Render Tree）由DOM树、CSSOM树合并而成，但并不是必须等DOM树及CSSOM树加载完成后才开始合并构建渲染树。三者的构建并无先后条件，亦非完全独立，而是会有交叉，并行构建。因此会形成一边加载，一边解析，一边渲染的工作现象。
    * 重排与重绘：根据渲染树进行重排与重绘，重排必将引起重绘，而重绘不一定会引起重排。重排会引起DOM树的重新构建，所以开销较大
        - 这里引出一个点position的absolute和relative与transform对元素进行移动，哪个开销较大：position开销较大，因为他会引起重排，至于transform开销较小（原因记得查一下）
4. 如何减少和避免重排
    * DocumentFragment进行缓存操作,引发一次回流和重绘；
    * 让元素脱离动画流，减少回流的Render Tree的规模；
    * 使用cloneNode(true or false) 和 replaceChild 技术，引发一次回流和重绘；

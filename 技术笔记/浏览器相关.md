1. 浏览器的组成
    * 浏览器主进程：主要进行网页的创建与销毁相关工作
    * GPU进程：css渲染GPU加速
    * 渲染进程
        - js线程
        - GUI渲染线程
        - 事件触发线程
        - 定时器触发线程
        - 异步http请求线程
        - 注意：js线程与GUI渲染线程互斥，这就是为什么js会阻塞DOM的根本原因
2. 浏览器内核一般是指浏览器的渲染进程
3. 浏览器加载流程
    * 构建DOM树：读取html文档 -> 将字节流解析成字符 -> 根据字符确定标签 -> 根据标签创建节点 -> 根据节点构建DOM树
    * 构建CSSOM树：读取css文档 -> 将字节流解析成字符 -> 根据字符确定标签 -> 根据标签创建节点 -> 根据节点构建CSSOM树
    * 加载JS：浏览器每遇见一个script标签，就会阻塞DOM树的构建，
    * 构建渲染树：渲染树（Render Tree）由DOM树、CSSOM树合并而成，但并不是必须等DOM树及CSSOM树加载完成后才开始合并构建渲染树。三者的构建并无先后条件，亦非完全独立，而是会有交叉，并行构建。因此会形成一边加载，一边解析，一边渲染的工作现象。
    * 重排与重绘：根据渲染树进行重排与重绘，重排必将引起重绘，而重绘不一定会引起重排。重排会引起DOM树的重新构建，所以开销较大
        - 这里引出一个点position的absolute和relative与transform对元素进行移动，哪个开销较大：position开销较大，因为他会引起重排，至于transform开销较小（原因记得查一下）
4. 如何减少和避免重排
    * DocumentFragment进行缓存操作,引发一次回流和重绘；
    * 让元素脱离动画流，减少回流的Render Tree的规模；
    * 使用cloneNode(true or false) 和 replaceChild 技术，引发一次回流和重绘；

5. 浏览器缓存策略: Web 缓存是指一个Web 资源（如html 页面，图片，js，数据等）存在于Web 服务器和客户端（浏览器）之间的副本。 缓存会根据进来的请求保存输出内容的副本；当下一个请求来到的时候，如果是相同的URL，缓存会根据缓存机制决定是直接使用副本响应访问请求，还是向源服务器再次发送请求。
6. [浏览器缓存](https://juejin.cn/post/6844903764566999054)，[第二篇](https://my.oschina.net/jathon/blog/404968)、[第三篇](https://juejin.cn/post/6844903737538920462)
7. 根据6的第二篇博客，分析怎么实习根据内容更改hash,webpack给我们提供了三种哈希值计算方式，分别是hash、chunkhash和contenthash。
   1. hash：跟整个项目的构建相关，构建生成的文件hash值都是一样的，只要项目里有文件更改，整个项目构建的hash值都会更改。
   2. chunkhash：根据不同的入口文件(Entry)进行依赖文件解析、构建对应的chunk，生成对应的hash值。
   3. contenthash：由文件内容产生的hash值，内容不同产生的contenthash值也不一样。
   4. 显然，我们是不会使用第一种的。改了一个文件，打包之后，其他文件的hash都变了，缓存自然都失效了。这不是我们想要的。
   5. 不同的应用场景：chunkhash和contenthash的主要应用场景是什么呢？在实际在项目中，我们一般会把项目中的css都抽离出对应的css文件来加以引用。如果我们使用chunkhash，当我们改了css代码之后，会发现css文件hash值改变的同时，js文件的hash值也会改变。这时候，contenthash就派上用场了。

